# Spring Security 知识点

目录
+ [SpringSecurity+JWT](#SpringSecurity+JWT)
  + [SpringSecurity的工作流程](#SpringSecurity的工作流程)
  + [SpringSecurity的重要概念](#SpringSecurity的重要概念)
  + [编码前的准备工作](#编码前的准备工作)
  + [代码中的具体实现](#代码中的具体实现)

## SpringSecurity+JWT
### SpringSecurity的工作流程
**Spring Security 的web基础是Filters：即通过一层层的Filters来对web请求做处理**。

一个web请求会经过一条过滤器链，在经过过滤器链的过程中会完成认证与授权，如果中间发现这条请求未认证或者未授权，会根据被保护API的权限去抛出异常，然后由异常处理器去处理这些异常。

![png](images/security基本原理图.jpeg)

如上图所示，一个请求想要访问到API就会以从左到右的形式经过蓝线框框里面的过滤器，其中绿色部分是负责认证的过滤器，蓝色部分负责异常处理，橙色部分则是负责授权。

图中的这两个绿色过滤器不会去说，因为这是Spring Security对form表单认证和Basic认证内置的两个Filter，而我们的demo是JWT认证方式所以用不上。

因为Spring Security自带的过滤器中是没有针对JWT这种认证方式的，所以我们的demo中会写一个JWT的认证过滤器，然后放在绿色的位置进行认证工作。

### SpringSecurity的重要概念
知道了Spring Security的大致工作流程之后，我们还需要知道一些非常重要的概念也可以说是组件：
- **SecurityContext**：上下文对象，Authentication对象会放在里面；
- **SecurityContextHolder**：用于拿到上下文对象的静态工具类；
- **Authentication**：认证接口，定义了认证对象的数据形式；
- **AuthenticationManager**：用于校验Authentication，返回一个认证完成后的Authentication对象。

#### SecurityContext
上下文对象，认证后的数据就放在这里面，接口定义如下：
```java
public interface SecurityContext extends Serializable {
 // 获取Authentication对象
 Authentication getAuthentication();

 // 放入Authentication对象
 void setAuthentication(Authentication authentication);
}
```
这个接口里面只有两个方法，其主要作用就是get or set Authentication。

#### SecurityContextHolder
```java
public class SecurityContextHolder {

 public static void clearContext() {
  strategy.clearContext();
 }

 public static SecurityContext getContext() {
  return strategy.getContext();
 }
    
    public static void setContext(SecurityContext context) {
  strategy.setContext(context);
 }
}
```
可以说是SecurityContext的工具类，用于get or set or clear SecurityContext，默认会把数据都存储到当前线程中。

#### Authentication
```java
public interface Authentication extends Principal, Serializable {
 
 Collection<? extends GrantedAuthority> getAuthorities();
 Object getCredentials();
 Object getDetails();
 Object getPrincipal();
 boolean isAuthenticated();
 void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException;
}
```
这几个方法效果如下：
- `getAuthorities`: 获取用户权限，一般情况下获取到的是用户的角色信息；
- `getCredentials`: 获取证明用户认证的信息，通常情况下获取到的是密码等信息；
- `getDetails`: 获取用户的额外信息，（这部分信息可以是我们的用户表中的信息）；
- `getPrincipal`: 获取用户身份信息，在未认证的情况下获取到的是用户名，在已认证的情况下获取到的是 UserDetails；
- `isAuthenticated`: 获取当前 Authentication 是否已认证；
- `setAuthenticated`: 设置当前 Authentication 是否已认证（true or false）。

`Authentication`只是定义了一种在SpringSecurity进行认证过的数据的数据形式应该是怎么样的，要有权限，要有密码，要有身份信息，要有额外信息。

#### AuthenticationManager
```java
public interface AuthenticationManager {
 // 认证方法
 Authentication authenticate(Authentication authentication)
   throws AuthenticationException;
}
```
`AuthenticationManager`定义了一个认证方法，它将一个未认证的`Authentication`传入，返回一个已认证的`Authentication`，默认使用的实现类为：**ProviderManager**。

接下来大家可以构思一下如何将这四个部分，串联起来，构成Spring Security进行认证的流程：
1. 先是一个请求带着身份信息进来；
2. 经过**AuthenticationManager**的认证；
3. 再通过**SecurityContextHolder**获取**SecurityContext**；
4. 最后将认证后的信息放入到**SecurityContext**。

### 编码前的准备工作
首先导入必要的依赖，数据库相关的依赖可以自行选择什么JDBC框架，这里用myabtis-plus
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>

<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
    <version>0.9.0</version>
</dependency>

<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-boot-starter</artifactId>
    <version>3.3.0</version>
</dependency>

<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>5.1.47</version>
</dependency>
```

#### 定义加密器Bean
```java
/**
 * 定义加密器Bean
 * @return
 */
@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
}
```
这个Bean是不必可少的，Spring Security在认证操作时会使用我们定义的这个加密器，如果没有则会出现异常。

#### 定义AuthenticationManager
```java
@Bean
public AuthenticationManager authenticationManager() throws Exception {
    return super.authenticationManager();
}

```
这里将Spring Security自带的authenticationManager声明成Bean，声明它的作用是用它帮我们进行认证操作，调用这个Bean的authenticate方法会由Spring Security自动帮我们做认证。

#### 实现UserDetailsService
```java
@Slf4j
@Service("userDetailsService")
public class CustomUserDetailsService implements UserDetailsService {
    @Autowired
    private UserInfoService userService;
    @Autowired
    private RoleInfoService roleInfoService;

    @Override
    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {
        log.info("开始登陆验证，用户名为: {}", s);

        // 根据用户名验证用户
        QueryWrapper<UserInfo> queryWrapper = new QueryWrapper<>();
        queryWrapper.lambda().eq(UserInfo::getUsername, s);
        UserInfo userInfo = userService.getOne(queryWrapper);
        if (userInfo == null) {
            throw new UsernameNotFoundException("用户名不存在，登陆失败。");
        }

        // 构建UserDetail对象
        UserDetail userDetail = new UserDetail();
        userDetail.setUserInfo(userInfo);
        List<RoleInfo> roleInfoList = roleInfoService.listRoleByUserId(userInfo.getId());
        userDetail.setRoleInfoList(roleInfoList);
        return userDetail;
    }
}
```
实现UserDetailsService的抽象方法并返回一个UserDetails对象，认证过程中SpringSecurity会调用这个方法访问数据库进行对用户的搜索，逻辑什么都可以自定义，无论是从数据库中还是从缓存中，但是我们需要将我们查询出来的用户信息和权限信息组装成一个UserDetails返回。

**UserDetails** 也是一个定义了数据形式的接口，用于保存我们从数据库中查出来的数据，其功能主要是验证账号状态和获取权限。

#### TokenUtil
由于我们是JWT的认证模式，所以我们也需要一个帮我们操作Token的工具类，一般来说它具有以下三个方法就够了：
- 创建token
- 验证token
- 反解析token中的信息

在下文代码里面，JwtProvider充当了Token工具类的角色。

### 代码中的具体实现
用SpringSecurity做JWT认证需要我们自己写一个过滤器来做JWT的校验，然后将这个过滤器放到开篇那张图的绿色部分。

在我们编写这个过滤器之前，我们还需要进行一个认证操作，因为我们要先访问认证接口拿到token，才能把token放到请求头上，进行接下来请求。

#### 认证方法
访问一个系统，一般最先访问的是认证方法，这里写了最简略的认证需要的几个步骤，因为实际系统中我们还要写登录记录啊，前台密码解密啊这些操作。
```java
@Service
public class AuthServiceImpl implements AuthService {

    @Autowired
    private AuthenticationManager authenticationManager;
    @Autowired
    private JwtProvider jwtProvider;

    @Override
    public Object login(String loginAccount, String password) {
        // 1 创建UsernamePasswordAuthenticationToken
        UsernamePasswordAuthenticationToken usernameAuthentication = new UsernamePasswordAuthenticationToken(loginAccount, password);
        // 2 认证
        Authentication authentication = authenticationManager.authenticate(usernameAuthentication);
        // 3 保存认证信息
        SecurityContextHolder.getContext().setAuthentication(authentication);
        // 4 生成自定义token
        UserDetail userDetail = (UserDetail) authentication.getPrincipal();
        AccessToken accessToken = jwtProvider.createToken(userDetail);

        // 5 放入缓存
        // ...
        return JSONUtil.parseObj(accessToken);
    }
}
```
这里一共五个步骤：
1. 传入用户名和密码创建了一个 **UsernamePasswordAuthenticationToken** 对象，这是我们前面说过的 **Authentication** 的实现类，传入用户名和密码做构造参数，这个对象就是我们创建出来的未认证的 **Authentication** 对象。
2. 使用我们先前已经声明过的Bean-**authenticationManager**调用它的**authenticate**方法进行认证，返回一个认证完成的**Authentication**对象。
3. 认证完成没有出现异常，就会走到第三步，使用**SecurityContextHolder**获取**SecurityContext**之后，将认证完成之后的**Authentication**对象，放入上下文对象。
4. 从**Authentication**对象中拿到我们的**UserDetails**对象，之前我们说过，认证后的**Authentication**对象调用它的getPrincipal()方法就可以拿到我们先前数据库查询后组装出来的**UserDetails**对象，然后创建**token**。
5. 把**UserDetails**对象放入缓存中，方便后面过滤器使用。

这样的话就算完成了，感觉上很简单，因为主要认证操作都会由authenticationManager.authenticate()帮我们完成。

接下来我们可以看看源码，从中窥得Spring Security是如何帮我们做这个认证的（省略了一部分）：
```java
// AbstractUserDetailsAuthenticationProvider
public Authentication authenticate(Authentication authentication){
  // 校验未认证的Authentication对象里面有没有用户名
  String username = (authentication.getPrincipal() == null) ? "NONE_PROVIDED": authentication.getName();  
    
     boolean cacheWasUsed = true;
     // 从缓存中去查用户名为XXX的对象
  UserDetails user = this.userCache.getUserFromCache(username);

     // 如果没有就进入到这个方法
  if (user == null) {
   cacheWasUsed = false;

   try {
    // 调用我们重写UserDetailsService的loadUserByUsername方法
    // 拿到我们自己组装好的UserDetails对象
    user = retrieveUser(username,
      (UsernamePasswordAuthenticationToken) authentication);
   }
   catch (UsernameNotFoundException notFound) {
    logger.debug("User '" + username + "' not found");

    if (hideUserNotFoundExceptions) {
     throw new BadCredentialsException(messages.getMessage(
       "AbstractUserDetailsAuthenticationProvider.badCredentials",
       "Bad credentials"));
    }
    else {
     throw notFound;
    }
   }

   Assert.notNull(user,
     "retrieveUser returned null - a violation of the interface contract");
  }
    
    try {
         // 校验账号是否禁用
   preAuthenticationChecks.check(user);
         // 校验数据库查出来的密码，和我们传入的密码是否一致
   additionalAuthenticationChecks(user,
     (UsernamePasswordAuthenticationToken) authentication);
  }
}
```
其主要逻辑也是查数据库然后对比密码。

登录效果如下：  
![png](images/登录效果图.png)

我们返回token之后，下次请求其他API的时候就要在请求头中带上这个token，都按照JWT的标准来做就可以。

#### JWT过滤器
有了token之后，我们要把过滤器放在过滤器链中，用于解析token，因为我们没有session，所以我们每次去辨别这是哪个用户的请求的时候，都是根据请求中的token来解析出来当前是哪个用户。

所以我们需要一个过滤器去拦截所有请求，前文我们也说过，这个过滤器我们会放在绿色部分用来替代**UsernamePasswordAuthenticationFilter**，所以我们新建一个**JwtAuthenticationTokenFilter**，然后将它注册为Bean，并在编写配置文件的时候需要加上这个：
```java
@Bean
public JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter() {
    return new JwtAuthenticationTokenFilter();
}

@Override
protected void configure(HttpSecurity http) throws Exception {
    http.addFilterBefore(jwtAuthenticationTokenFilter(),UsernamePasswordAuthenticationFilter.class);
}
```
addFilterBefore的语义是添加一个Filter到XXXFilter之前，放在这里就是把**JwtAuthenticationTokenFilter**放在**UsernamePasswordAuthenticationFilter**之前，因为filter的执行也是有顺序的，我们必须要把我们的filter放在过滤器链中绿色的部分才会起到自动认证的效果。

接下来我们可以看看JwtAuthenticationTokenFilter的具体实现了：
```java
@Slf4j
public class JwtAuthenticationTokenFilter extends OncePerRequestFilter {

    @Autowired
    private JwtProvider jwtProvider;
    @Autowired
    private JwtProperties jwtProperties;

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain chain) throws ServletException, IOException {
        log.info("JWT过滤器通过校验请求头token进行自动登录...");

        // 拿到Authorization请求头内的信息
        String authToken = jwtProvider.getToken(request);

        // 判断一下内容是否为空
        if (StrUtil.isNotEmpty(authToken) && authToken.startsWith(jwtProperties.getTokenPrefix())) {
            // 去掉token前缀(Bearer )，拿到真实token
            authToken = authToken.substring(jwtProperties.getTokenPrefix().length());

            // 拿到token里面的登录账号
            String loginAccount = jwtProvider.getSubjectFromToken(authToken);

            if (StrUtil.isNotEmpty(loginAccount) && SecurityContextHolder.getContext().getAuthentication() == null) {
                // 缓存里查询用户，不存在需要重新登陆
                //UserDetail userDetails = caffeineCache.get(CacheName.USER, loginAccount, UserDetail.class);
                UserDetail userDetails = null;

                // 拿到用户信息后验证用户信息与token
                if (userDetails != null && jwtProvider.validateToken(authToken, userDetails)) {

                    // 组装authentication对象，构造参数是Principal Credentials 与 Authorities
                    // 后面的拦截器里面会用到 grantedAuthorities 方法
                    UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, userDetails.getPassword(), userDetails.getAuthorities());

                    // 将authentication信息放入到上下文对象中
                    SecurityContextHolder.getContext().setAuthentication(authentication);

                    log.info("JWT过滤器通过校验请求头token自动登录成功, user : {}", userDetails.getUsername());
                }
            }
        }
        chain.doFilter(request, response);
    }
}
```
1. 拿到Authorization请求头对应的token信息。
2. 去掉token的头部(Bearer )。
3. 解析token，拿到我们放在里面的登陆账号。
4. 因为我们之前登陆过，所以我们直接从缓存里面拿我们的UserDetail信息即可。
5. 查看是否UserDetail为null，以及查看token是否过期，UserDetail用户名与token中的是否一直。
6. 组装一个authentication对象，把它放在上下文对象中，这样后面的过滤器看到我们上下文对象中有authentication对象，就相当于我们已经认证过了。

这样的话，每一个带有正确token的请求进来之后，都会找到它的账号信息，并放在上下文对象中，我们可以使用SecurityContextHolder很方便的拿到上下文对象中的Authentication对象。


结合认证方法，我们的逻辑链就变成了：
登录👉拿到token👉请求带上token👉JWT过滤器拦截👉校验token👉将从缓存中查出来的对象放到上下文中