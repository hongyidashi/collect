# Redis 知识点

目录
- [Redis主从复制](#Redis主从复制)
  + [主从复制步骤](#主从复制步骤)
  + [Redis主从节点是如何判断数据是否一致的](#Redis主从节点是如何判断数据是否一致的)
  + [Redis运行ID](#Redis运行ID)
  + [全量复制过程](#全量复制过程)
  + [部分复制过程](#部分复制过程)
  + [心跳机制](#心跳机制)

## <span id="Redis主从复制">Redis主从复制</span>

### <span id="主从复制步骤">主从复制步骤</span>
1. 从节点执行salveof命令；
2. 现在的从节点只是保存主节点的信息，还没有发起复制；
3. 从节点内部的一个定时任务会发现有主节点的信息，然后开始用socket连接主节点；
4. 建立连接成功后会发送`ping`命令，如果通信正常主节点会返回`pong`，否则重新连接；
5. 如果主节点设置了权限，那么就需要验证权限，如果不通过验证，则复制终止；
6. 权限验证通过后，就开始同步数据，主节点将把所有数据发送给从节点；
7. 主节点将数据发送给从节点后，就完成了复制的建立流程，接下来主节点会持续把**写命令**发给从节点，以保持数据一致性。

### <span id="Redis主从节点是如何判断数据是否一致的">Redis主从节点是如何判断数据是否一致的</span>
答曰：通过主从节点各自复制偏移量来确认主从节点数据是否一致。  
~~你不会不知道什么是偏移量吧？不会真有人不知道偏移量吧？kafka？offset？不会吧不会吧不会吧？~~

1. 参与主从复制的节点都会自身维护一个复制偏移量；
2. 主节点在处理完写命令后，会把命令的字节长度做累加记录，统计信息在info replication 中的 masterreploffset 指标中；
3. 从节点每秒钟会向主节点汇报自身的复制偏移量，因此主节点也会保存从节点的复制偏移量；
4. 从节点在接收到主节点发送的命令后，也会累加自身的偏移量，统计信息在info replication 中；
5. 通过对比主从的偏移量判断是否数据一致。

### <span id="Redis运行ID">Redis运行ID</span>
~~吾弟：啊，这，啥玩意？~~

1. 每个Redis节点**启动的时候**，都会生成一个40位的运行ID（**每次启动的时候都会生成不一样的**）；
2. 这个ID是用于标识Redis节点的。如果采用 ip + port 的方式确定一个节点，那么主节点重启，并修改了 AOF/RDB 文件中的数据话，从节点再基于偏移量同步数据将是不安全的，可能会数据不一致。SO，当主节点运行ID变化后，从节点将会进行全量复制，也就是说，Redis重启后会默认从主节点进行全量复制。

### <span id="全量复制过程">全量复制过程</span>
1. 从节点向主节点发送 psync 命令；(这就是个请求同步的命令，有兴趣自己去了解吧)
2. 主节点根据命令返回 FULLRESYNC；
3. 从节点记录主节点的运行ID和offset(偏移量)；
4. 主节点执行 bgsave 将保存RDB文件到本地；(你不会不知道bgsave是啥吧，不会吧不会吧不会吧)
5. 主节点发送 RBD 文件到从节点；
6. 从节点收到 RDB 文件并加载到内存中；
7. 主节点在从节点接收数据的期间，将新来的数据保存到 **[复制积压缓冲区](#复制积压缓冲区)** ，当从节点将RDB加载完毕再发送过去；(又不知道复制积压缓冲区是个嘛玩意儿了是吧)
8. 从节点清空数据后加载 RDB 文件；
9. 从节点成功加载完 RBD 后，如果开启了 AOF，会立刻做 bgrewriteaof。(这玩意儿估计你也忘了)

> **防止你骂我，特地简单说一下 psync**  
> 命令格式为 psync{runId}{offset}  
> runId：从节点所复制主节点的运行 id  
> offset：当前从节点已复制的数据偏移量，如果是第一次复制则为 -1  
> 主节点会根据 runid 和 offset 决定返回结果：
> 1. 如果回复 +FULLRESYNC {runId} {offset} ，那么从节点将触发全量复制流程；
> 2. 如果回复 +CONTINUE，从节点将触发部分复制；
> 3. 如果回复 +ERR，说明主节点不支持 2.8 的 psync 命令，将使用 sync 执行全量复制。

#### <span id="复制积压缓冲区">复制积压缓冲区</span>
1. 这东西是保存在主节点的一个固定长度的FIFO队列，默认大小1MB；
2. 这个队列在salve连接时建立的，这时主节点响应写命令时不但会将命令发送给从节点还会将命令写入缓冲区；
3. 它的作用是用于部分复制和复制命令丢失的数据补救。

> 差点忘了 bgrewriteaof  
> Redis Bgrewriteaof 命令用于异步执行一个 AOF（AppendOnly File） 文件重写操作。重写会创建一个当前 AOF 文件的体积优化版本。即使 Bgrewriteaof 执行失败，也不会有任何数据丢失，因为旧的 AOF 文件在 Bgrewriteaof 成功之前不会被修改。  
> —— 以上来自《菜鸟教程》

### <span id="部分复制过程">部分复制过程</span>
既然有全量复制，那必定有部分复制~~个屁咧~~，但其实部分复制是Redis2.8之后才支持的，之前只支持全量复制。

1. 当从节点出现网络问题或其他问题与从节点通信中断，且超过了 repl-timeout 时间，主节点就会中断复制连接；
2. 主节点会将请求的数据写入到“复制积压缓冲区”；
3. 当和从节点通信恢复时，从节点会将 offset 和主节点 id 发送到主节点；
4. 主节点校验后，如果**偏移量后的数据在缓冲区中**，就发送 cuntinue 响应 —— 表示可以进行部分复制；
5. 主节点将缓冲区的数据发送到从节点，保证主从复制进行正常状态。
