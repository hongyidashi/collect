# MySQL 知识点

目录
+ [主从复制](#主从复制)
+ [redo-log和undo-log](#redo-log和undo-log)
  - [redo-log](#redo-log)
+ [MySQL架构](#MySQL架构)
+ [MySQL存储引擎](#MySQL存储引擎)
+ [MySQL数据类型](#MySQL数据类型)
+ [MySQL索引](#MySQL索引)

## <span id="主从复制">主从复制</span>

### 为什么要主从复制
1. 可以为读写分离提供支持；
2. 做数据的热备，主库宕机后能够及时替换主库，保证业务可用性；
3. ... 自己补充吧

### 主从复制是啥
MySQL 主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点。

### 主从复制原理
1. 数据库有个 binlog 二进制文件，记录所有更新事件(update、insert、delete)；
2. 我们的目标就是把主数据库的 binlog 文件的更新事件复制过来；
3. 让其在从数据库的 relay log 中继日志文件中再执行一次这些更新即可；
4. 具体需要三个线程来操作：
  - binlog输出线程：用于将 binlog 推送到从库；
  - 从库I/O线程：该线程连接到主库并请求主库发送 binlog 里面的更新记录到从库上；从库I/O线程读取主库的 binlog 输出线程发送的更新并拷贝这些更新到本地文件 relay log；
  - 从库的SQL线程：这个线程读取从库I/O线程写到 relay log 的更新事件并执行。

### 主从复制流程
上图！  
![主从复制流程](images/主从复制流程.png)  

1. 主库的更新事件被写到binlog；
2. 从库启动并发起连接，连接到主库
3. 主库创建一个 binlog dump thread，把 binlog 推送的从库；
4. 从库启动后，创建一个I/O线程，把从主库传过来的 binlog 写到 relay log；
5. 创建一个SQL线程，从 relay log 里面读取内容，从 Exec_Master_Log_Pos 位置开始执行读取到的更新事件，将更新内容写入到slave的db


## <span id="redo-log和undo-log">redo-log和undo-log</span>
这两个log都是为MySQL innodb的事务提供支持的，redo log 是重做日志，提供前滚操作，undo log 是回滚日志，提供回滚操作。  

**undo log并不是redo log的逆向过程！！！**  
1. redo log 通常是物理日志，记录的数据页的物理修改，而不是某一行或几行修改成怎样，它用来恢复提交后的数据页；
2. undo用来回滚行记录到某个版本。undo log一般是逻辑日志，根据每行记录进行记录。

### <span id="redo-log">redo-log</span>

#### 基本概念
redo log包括两部分：内存中的日志缓存(redo log buffer)，该部分日志是易失性的；磁盘上的重做日志文件(redo log file)，该部分日志是持久的。

在概念上，innodb通过force log at commit机制实现事务的持久性，即在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的redo log file和undo log file中进行持久化。

为了确保每次日志都能写入到事务日志文件中，在每次将log buffer中的日志写入日志文件的过程中都会调用一次操作系统的fsync操作(即fsync()系统调用)。因为MySQL是工作在用户空间的，MySQL的log buffer处于用户空间的内存中。要写入到磁盘上的log file中(redo:ib_logfileN文件,undo:share tablespace或.ibd文件)，中间还要经过操作系统内核空间的os buffer，调用fsync()的作用就是将OS buffer中的日志刷到磁盘上的log file中。也就是说，要从redo log buffer写日志到磁盘的redo log file中：  
![写入磁盘过程](images/writer-log.png)  

> 一般所说的log file并不是磁盘上的物理日志文件，而是操作系统缓存中的log file，官方手册上的意思也是如此。  
> 所以在本文后续内容中都以os buffer或者file system buffer来表示官方手册中所说的Log file，然后log file则表示磁盘上的物理日志文件，即log file on disk。  
> 看不懂了吧，爷也不懂，凎。。。

MySQL支持用户自定义在commit时如何将log buffer中的日志刷log file中，可通过一个变量（innodb_flush_log_at_trx_commit 的值）来控制 —— 0、1、2，默认为1：
- 1：事务每次提交都会将log buffer中的日志写入os buffer并调用fsync()刷到log file on disk中；数据安全性最高，但IO的性能较差，因为每次都要写入磁盘；
- 0：事务提交时不会将log buffer中日志写入到os buffer，而是每秒写入os buffer并调用fsync()写入到log file on disk中；
- 2：每次提交都仅写入到os buffer，然后是每秒调用fsync()将os buffer中的日志写入到log file on disk。

图来！  
![示意图](images/事务日志模式示意图.png)  

注意，**这个变量只是控制commit动作是否刷新log buffer到磁盘。**


#### 日志块 log block
innodb存储引擎中，redi log 以块为单位存储，每个块占512字节，这称为redo log block。所以不管是log buffer中还是os buffer中以及redo log file on disk中，都是这样以512字节的块存储的。

每个redo log block由3部分组成：**日志块头**、**日志块尾**和**日志主体**，其中日志块头占用12字节，日志块尾占用8字节，所以每个redo log block的日志主体部分只有512-12-8=492字节。

因为redo log记录的是数据页的变化，当一个数据页产生的变化需要使用超过492字节的redo log来记录，那么就会使用多个redo log block来记录该数据页的变化。

#### 日志刷盘的规则
log buffer中未刷到磁盘的日志称为脏日志(dirty log)。

在上面的说过，默认情况下事务每次提交的时候都会刷事务日志到磁盘中，这是因为变量 innodb_flush_log_at_trx_commit 的值为1。但是innodb不仅仅只会在有commit动作后才会刷日志到磁盘，这只是innodb存储引擎刷日志的规则之一。

刷日志到磁盘有以下几种规则：
1. 发出commit动作时，commit发出后是否刷日志由变量 innodb_flush_log_at_trx_commit 控制；
2. 每秒刷一次。这个刷日志的频率由变量 innodb_flush_log_at_timeout 值决定，默认是1秒。要注意，这个刷日志频率和commit动作无关；
3. 当log buffer中已经使用的内存超过一半时；
4. 当有checkpoint时，[checkpoint](#数据页刷盘的规则及checkpoint)在一定程度上代表了刷到磁盘时日志所处的[LSN](#LSN)位置。

---

**接下来将进入彻底懵逼模式，需要时间再补充**

---

#### <span id="数据页刷盘的规则及checkpoint">数据页刷盘的规则及checkpoint</span>
内存中(buffer pool)未刷到磁盘的数据称为脏数据(dirty data)。由于数据和日志都以页的形式存在，所以脏页表示脏数据和脏日志。

上一节介绍了日志是何时刷到磁盘的，不仅仅是日志需要刷盘，脏数据页也一样需要刷盘。

在innodb中，数据刷盘的规则只有一个：checkpoint。但是触发checkpoint的情况却有几种。不管怎样，checkpoint触发后，会将buffer中脏数据页和脏日志页都刷到磁盘。

innodb存储引擎中checkpoint分为两种：
1. sharp checkpoint：在重用redo log文件(例如切换日志文件)的时候，将所有已记录到redo log中对应的脏数据刷到磁盘；
2. fuzzy checkpoint：一次只刷一小部分的日志到磁盘，而非将所有脏日志刷盘。有以下几种情况会触发该检查点：
  - master thread checkpoint：由master线程控制，每秒或每10秒刷入一定比例的脏页到磁盘；
  - flush_lru_list checkpoint：从MySQL5.6开始可通过 innodb_page_cleaners 变量指定专门负责脏页刷盘的page cleaner线程的个数，该线程的目的是为了保证lru列表有可用的空闲页
  - async/sync flush checkpoint：同步刷盘还是异步刷盘。例如还有非常多的脏页没刷到磁盘(非常多是多少，有比例控制)，这时候会选择同步刷到磁盘，但这很少出现；如果脏页不是很多，可以选择异步刷到磁盘，如果脏页很少，可以暂时不刷脏页到磁盘；
  - dirty page too much checkpoint：脏页太多时强制触发检查点，目的是为了保证缓存有足够的空闲空间。too much的比例由变量 innodb_max_dirty_pages_pct 控制，MySQL 5.6默认的值为75，即当脏页占缓冲池的百分之75后，就强制刷一部分脏页到磁盘

由于刷脏页需要一定的时间来完成，所以记录检查点的位置是在每次刷盘结束之后才在redo log中标记的。


#### <span id="LSN">LSN</span>
TODO 应该是弃坑了


## MySQL架构
MySQL的架构和其他数据库的架构区别主要体现在存储引擎的架构上，**插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离**。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。

主要分为4层：
1. **连接层**：最上层是一些客户端和连接服务。**主要完成一些类似于连接处理、授权认证、及相关的安全方案**。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。
2. **服务层**：第二层服务层，主要完成大部分的核心服务功能，**包括查询解析、分析、优化、缓存、以及所有的内置函数**，所有跨存储引擎的功能也都在这一层实现，包括触发器、存储过程、视图等。
3. **引擎层**：第三层存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务层通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。
4. **存储层**：第四层为数据存储层，主要是将数据存储在运行于该设备的文件系统之上，并完成与存储引擎的交互。

> #### MySQL的查询流程具体是？一条SQL语句在MySQL中如何执行的？

客户端请求 ---> 连接器（验证用户身份，给予权限）  ---> 查询缓存（存在缓存则直接返回，不存在则执行后续操作） ---> 分析器（对SQL进行词法分析和语法分析操作）  ---> 优化器（主要对执行的sql优化选择最优的执行方案方法）  ---> 执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口） ---> 去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）

![png](images/MySQL查询流程.png)

## MySQL存储引擎
存储引擎是MySQL的组件，用于处理不同表类型的SQL操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。

使用哪一种引擎可以灵活选择，**一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求**，使用合适的存储引擎，将会提高整个数据库的性能。

MySQL服务器使用可插拔的存储引擎体系结构，可以从运行中的 MySQL 服务器加载或卸载存储引擎。

### 查看存储引擎
```mysql
# 查看支持的存储引擎
SHOW ENGINES

# 查看默认存储引擎
SHOW VARIABLES LIKE 'storage_engine'

# 查看具体某一个表所使用的存储引擎，这个默认存储引擎被修改了！
show create table tablename

# 准确查看某个数据库中的某一表所使用的存储引擎
show table status like 'tablename'
show table status from database where name="tablename"
```

### 存储引擎对比
常见的存储引擎就 InnoDB、MyISAM；

InnoDB 现在是 MySQL 默认的存储引擎，**支持事务、行级锁定和外键**

### 文件存储结构对比
在 MySQL中建立任何一张数据表，在其数据目录对应的数据库目录下都有对应表的 `.frm` 文件，`.frm` 文件是用来保存每个数据表的元数据(meta)信息，包括表结构的定义等，与数据库存储引擎无关，也就是任何存储引擎的数据表都必须有.frm文件，命名方式为 数据表名.frm，如user.frm。

查看MySQL 数据保存在哪里：`show variables like 'data%'`

InnoDB 物理文件结构为：
- **.frm 文件**：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等；
- **.ibd 文件或 .ibdata 文件**：这两种文件都是存放 InnoDB 数据的文件，之所以有两种文件形式存放 InnoDB 的数据，是因为 InnoDB 的数据存储方式能够通过配置来决定是使用**共享表空间**存放存储数据，还是用**独享表空间**存放存储数据。

独享表空间存储方式使用.ibd文件，并且每个表一个.ibd文件共享表空间存储方式使用.ibdata文件，所有表共同使用一个.ibdata文件（或多个，可自己配置）

MyISAM 物理文件结构为：
- **.frm文件**：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等；
- **.MYD (MYData) 文件**：MyISAM 存储引擎专用，用于存储 MyISAM 表的数据；
- **.MYI (MYIndex)文件**：MyISAM 存储引擎专用，用于存储 MyISAM 表的索引相关信息。

> #### 说说MySQL有哪些存储引擎？都有哪些区别？

常见存储引擎有 InnoDB、MyISAM。  
主要区别为：  
1. InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；
2. InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；
3. InnoDB 是聚簇索引，MyISAM 是非聚簇索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据，因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针；主键索引和辅助索引是独立的。
4. InnoDB 不保存表的具体行数，执行select count(*) from table 时需要全表扫描。而 MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快。
5. InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁 —— 一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限；这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一。

> #### 一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？  

1. 如果表的类型是 MyISAM，那么是18。因为MyISAM表会把自增主键的最大ID记录到数据文件中，重启MySQL自增主键的最大ID也不会丢失；
2. 如果表的类型是InnoDB，那么是15。因为InnoDB 表只是把自增主键的最大ID记录到内存中，所以重启数据库或对表进行OPTION操作，都会导致最大ID丢失。


> #### 哪个存储引擎执行 select count(*) 更快，为什么?
  
MyISAM更快，因为MyISAM内部维护了一个计数器，可以直接调取。

## MySQL数据类型
主要包括以下五大类：
- 整数类型：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT；
- 浮点数类型：FLOAT、DOUBLE、DECIMAL；
- 字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB；
- 日期类型：Date、DateTime、TimeStamp、Time、Year；
- 其他数据类型：BINARY、VARBINARY、ENUM、SET、Geometry、Point、MultiPoint、LineString、MultiLineString、Polygon、GeometryCollection等。

> #### CHAR 和 VARCHAR 的区别？  
简单来说就是 **char是固定长度，varchar长度可变**：
- char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符；
- 存储时，前者不管实际存储数据的长度，直接按 char 规定的长度分配存储空间；而后者会根据实际存储的数据分配最终的存储空间。

相同点：
- char(n)，varchar(n)中的n都代表字符的个数；
- 超过char，varchar最大长度n的限制后，字符串会被截断。

不同点：
- char不论实际存储的字符数都会占用n个字符的空间，而varchar只会占用实际字符应该占用的字节空间加1（实际长度length，0<=length<255）或加2（length>255），因为varchar保存数据时除了要保存字符串之外还会加一个字节来记录长度（如果列声明长度大于255则使用两个字节来保存长度）；
- 能存储的最大空间限制不一样：char的存储上限为255字节；
- char在存储时会截断尾部的空格，而varchar不会。

char是适合存储很短的、一般固定长度的字符串。例如，char非常适合存储密码的MD5值，因为这是一个定长的值。**对于非常短的列，char比varchar在存储空间上也更有效率**。

> #### BLOB和TEXT有什么区别？
1. BLOB 是一个二进制对象，可以容纳可变数量的数据。有四种类型的BLOB：TINYBLOB、BLOB、MEDIUMBLOB和 LONGBLOB（小，正常，中，大BLOB）；
2. TEXT是一个不区分大小写的BLOB。四种TEXT类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT；
3. BLOB 保存二进制数据，TEXT 保存字符数据。

## MySQL索引

> #### 说说你对 MySQL 索引的理解？
1. MYSQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构，所以说索引的本质是：数据结构，索引的目的在于提高查询效率；
2. 可以简单的理解为“排好序的快速查找数据结构”，数据本身之外；
3. 索引本身也很大，不可能全部存储在内存中，一般以索引文件的形式存储在磁盘上；
4. 平常说的索引，没有特别指明的话，就是B+树（多路搜索树，不一定是二叉树）结构组织的索引。其中聚集索引，次要索引，覆盖索引，符合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。此外还有哈希索引等。

> #### 使用索引有什么优缺点
优点：
1. 提高数据检索效率，降低数据库IO成本；  
2. 降低数据排序的成本，降低CPU的消耗。

缺点：
1. 索引也是一张表，保存了主键和索引字段，并指向实体表的记录，所以也需要占用内存；
2. 虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE；因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。

### 索引分类
数据结构角度：
- B+树索引
- Hash索引
- Full-Text全文索引
- R-Tree索引

从物理存储角度：
- 聚集索引（clustered index）
- 非聚集索引（non-clustered index），也叫辅助索引（secondary index）

从逻辑角度：
- 主键索引：主键索引是一种特殊的唯一索引，不允许有空值；
- 普通索引或者单列索引：每个索引只包含单个列，一个表可以有多个单列索引；
- 多列索引（复合索引、联合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合；
- 唯一索引或者非唯一索引；
- 空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建。

### MySQL索引结构
首先要明白索引（index）是在**存储引擎（storage engine）层面实现**的，而不是server层面。不是所有的存储引擎都支持所有的索引类型。即使多个存储引擎支持某一索引类型，它们的实现和行为也可能有所差别。

#### B+Tree索引
MyISAM 和 InnoDB 存储引擎，都使用 B+Tree 的数据结构，它相对与 B-Tree 结构，所有的数据都存放在叶子节点上，且把叶子节点通过指针连接到一起，形成了一条数据链表，以加快相邻数据的检索效率。

**先了解下 B-Tree 和 B+Tree 的区别**  

**B-Tree**  
B-Tree是为磁盘等外存储设备设计的一种平衡查找树。  
系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。  
InnoDB 存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB 存储引擎中默认每个页的大小为16KB，可通过参数 innodb_page_size 将页的大小设置为 4K、8K、16K；  
而系统一个磁盘块的存储空间往往没有这么大，因此 InnoDB 每次申请磁盘空间时都会读**若干地址连续磁盘块**来达到页的大小 16KB。InnoDB 在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。  
B-Tree 结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述 B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data 为一行记录中除主键外的数据。对于不同的记录，key值互不相同。  
一棵m阶的B-Tree有如下特性：
1. 每个节点最多有m个孩子；
2. 除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子；
3. 若根节点不是叶子节点，则至少有2个孩子；
4. 所有叶子节点都在同一层，且不包含其它关键字信息；
5. 每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn）
6. 关键字的个数n满足：ceil(m/2)-1 <= n <= m-1；
7. ki(i=1,…n)为关键字，且关键字升序排序；
8. Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)。

B-Tree 中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个 3 阶的 B-Tree：  
![png](images/3阶B-Tree.png)

每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。  

模拟查找关键字29的过程：
1. 根据根节点找到磁盘块1，读入内存；【磁盘I/O操作第1次】
2. 比较关键字29在区间（17,35），找到磁盘块1的指针P2；
3. 根据P2指针找到磁盘块3，读入内存；【磁盘I/O操作第2次】
4. 比较关键字29在区间（26,30），找到磁盘块3的指针P2；
5. 根据P2指针找到磁盘块8，读入内存；【磁盘I/O操作第3次】
6. 在磁盘块8中的关键字列表中找到关键字29。

分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素。B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。


> 为什么MySQL 索引中用B+tree，不用B-tree 或者其他树，为什么不用 Hash 索引



