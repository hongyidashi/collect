# 面试题


### MySQL索引使用有哪些注意事项呢？
可以从这两个维度回答这个问题：索引哪些情况会失效，索引不适合哪些场景

#### 索引哪些情况会失效
- 查询条件包含or，可能导致索引失效
- 如果字段类型是字符串，where时一定用引号括起来，否则索引失效
- like通配符可能导致索引失效
- 联合索引，查询时的条件列不是联合索引中的第一个列，索引失效
- 在索引列上使用mysql的内置函数，索引失效
- 对索引列运算（如，+、-、*、/），索引失效
- 索引字段上使用（！= 或者 < >，not in）时，可能会导致索引失效
- 索引字段上使用is null， is not null，可能导致索引失效
- 左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效
- mysql估计使用全表扫描要比使用索引快,则不使用索引

#### 索引不适合哪些场景
- 数据量少的不适合加索引
- 更新比较频繁的也不适合加索引
- 区分度低的字段不适合加索引（如性别）

### MySQL遇到过死锁问题吗，你是如何解决的？
排查死锁的一般步骤是酱紫的：
1. 查看死锁日志show engine innodb status
2. 找出死锁SQL
3. 分析SQL加锁情况
4. 模拟死锁案发
5. 分析死锁日志
6. 分析死锁结果

### 日常工作中你是怎么优化SQL的？
可以从这几个维度回答这个问题：
1. 加索引
2. 避免返回不必要的数据
3. 适当分批量进行
4. 优化sql结构
5. 分库分表
6. 读写分离

### InnoDB与MyISAM的区别
- InnoDB支持事务，MyISAM不支持事务
- InnoDB支持外键，MyISAM不支持外键
- InnoDB 支持 MVCC(多版本并发控制)，MyISAM 不支持
- select count(*) from table时，MyISAM更快，因为它有一个变量保存了整个表的总行数，可以直接读取，InnoDB就需要全表扫描。
- Innodb不支持全文索引，而MyISAM支持全文索引（5.7以后的InnoDB也支持全文索引）
- InnoDB支持表、行级锁，而MyISAM支持表级锁
- InnoDB表必须有主键，而MyISAM可以没有主键
- Innodb表需要更多的内存和存储，而MyISAM可被压缩，存储空间较小
- Innodb按主键大小有序插入，MyISAM记录插入顺序是，按记录插入顺序保存。
- InnoDB 存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全，与 MyISAM 比 InnoDB 写的效率差一些，并且会占用更多的磁盘空间以保留数据和索引

### 聚集索引与非聚集索引的区别
- 一个表中只能拥有一个聚集索引，而非聚集索引一个表可以存在多个
- 聚集索引，索引中键值的逻辑顺序决定了表中相应行的物理顺序；非聚集索引，索引中索引的逻辑顺序与磁盘上的行物理存储顺序不同
- 索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块

聚集索引：物理存储按照索引排序  
非聚集索引：物理存储不按照索引排序；

### limit 1000000加载很慢的话，你是怎么解决的呢？
**方案一**  
如果id是连续的，可以这样，返回上次查询的最大记录(偏移量)，再往下limit  
`select id,name from employee where id > 1000000 limit 10`

**方案二**  
在业务允许的情况下限制页数：  
建议跟业务讨论，有没有必要查这么后的分页啦。因为绝大多数用户都不会往后翻太多页。

**方案三**  
order by + 索引（id为索引）  
`select id,name from employee order by id limit 1000000,10`

**方案四**  
利用延迟关联或者子查询优化超多分页场景。（先快速定位需要获取的id段，然后再关联）  
`SELECT a.* FROM employee a ,(select id from employee where 条件 LIMIT 1000000,10)b where a.id = b.id`

