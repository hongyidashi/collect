# 小红书面试(伪)

[TOC]

## 零、开篇

本文根据网络流传的面试题进行提问和回答，回答内容不保证正确，仅供参考。

## 一、IO模型

### 1. 讲一下BIO，NIO，AIO的区别

这三种IO是用于处理I/O操作的不同编程模型。IO分为两个阶段：数据准备阶段和数据拷贝阶段。

BIO是传统的I/O模型，也叫做同步阻塞I/O。在BIO中，当一个线程执行I/O操作时，在数据准备和数据拷贝阶段都会被阻塞，直到整个操作完成。这意味着线程在进行I/O操作时无法执行其他任务，必须等待操作完成后才能继续。如果有多个连接需要处理，就需要创建多个线程来处理，可能导致线程数量增加和资源消耗较大。

NIO是Java 1.4引入的新的I/O模型，也称为同步非阻塞I/O。在NIO中，当一个线程执行I/O操作时，会轮询数据是否准备完成，即数据准备阶段是非阻塞的，但数据拷贝阶段仍需等待。NIO引入了通道（Channel）和缓冲区（Buffer）的概念，线程从通道中读取数据并将其存入缓冲区，或者将数据从缓冲区写入通道。NIO的主要特点是可以使用一个线程处理多个连接，即一个线程可以管理多个通道。这样可以减少线程的数量，提高系统的并发性能。

AIO是Java 1.7引入的新的I/O模型，也称为异步非阻塞I/O。在AIO中，当一个线程执行I/O操作时，数据准备阶段和数据拷贝阶段都不会阻塞等待操作完成，而是可以继续执行其他任务。当操作完成后，会通过回调机制通知应用程序。AIO适用于需要处理大量并发连接的场景。

所以，简单来说，BIO适用于连接数较少的情况，NIO适用于连接数较多的情况，而AIO适用于需要处理大量并发连接的情况。

### 2. NIO中是如何实现一个线程管理多个通道的？

在NIO中，通过使用选择器（Selector）来实现一个线程管理多个通道。

选择器是NIO提供的一个关键组件，它可以注册多个通道，并且在这些通道上进行异步I/O操作的监控。选择器使用了事件驱动的模型，可以检测到通道上的事件，例如数据可读、数据可写等。

### 3. Ngnix的IO模型是什么？

Nginx采用了Reactor模式。它通过异步非阻塞IO、基于多路复用技术（如epoll、kqueue等）等来实现高效的事件处理。在Nginx中，主要的IO操作是异步非阻塞的，即当一个IO操作启动后，Nginx并不会阻塞等待操作的完成。当IO操作完成时，Nginx会通过事件通知机制来处理已完成的IO事件，以便进一步处理数据。

Nginx的IO模型具有以下特点：

1. 高并发性：采用异步非阻塞的IO模型，可以处理大量的并发连接，提供高性能和高吞吐量。
2. 资源效率：通过多路复用技术，一个线程可以同时管理多个连接，减少线程和内存资源的消耗。
3. 高可扩展性：由于采用了事件驱动的模型，可以轻松地扩展和处理更多的连接和请求。
4. 低延迟：非阻塞的IO操作和异步事件处理能够减少IO等待时间，提供较低的延迟。

总结来说，Nginx的IO模型是基于事件驱动、异步非阻塞的IO处理方式，通过多路复用技术实现高并发性、资源效率和低延迟的特性。

> **Reactor和AIO的区别**
>
> Reactor和AIO都是异步非阻塞的，那它们有什么区别呢？
>
> "Reactor"和"AIO"是两个不同的概念，它们在I/O模型和处理方式上有一些区别。
>
> 1. Reactor（反应器）模式： Reactor模式是一种事件驱动的设计模式，常用于构建高性能的服务器应用程序。在Reactor模式中，有一个事件循环线程（通常称为主Reactor线程），它负责监听和接收事件（例如连接、读取和写入）的到来。主Reactor线程使用非阻塞IO方式来接收这些事件，然后将事件分发给对应的处理器进行处理。处理器可以是主Reactor线程本身，也可以是其他工作线程（称为从Reactor线程），用于实际的业务逻辑处理。
> 2. AIO（Asynchronous I/O）： AIO是一种异步非阻塞的I/O模型。它是**基于操作系统**提供的异步I/O机制实现的，允许应用程序在I/O操作完成之前继续执行其他任务。在AIO中，应用程序发起一个I/O操作后，会得到一个回调对象或Future对象，当操作完成时，操作系统会通知应用程序进行进一步处理。AIO适用于需要处理大量并发连接的场景，可以有效地提高系统的吞吐量和并发性能。
>
> 因此，Reactor模式是一种**设计模式**，用于构建事件驱动的服务器应用程序，而AIO是一种基于异步非阻塞I/O的编程模型。Reactor模式可以使用不同的I/O模型实现，包括阻塞式I/O、非阻塞式I/O和AIO。在Java中，NIO提供了一种基于Reactor模式的非阻塞式I/O模型，而AIO提供了一种基于AIO的异步I/O模型。
>
> 请注意，Reactor模式和AIO并不是互斥的概念，可以结合使用。在实际应用中，可以使用Reactor模式来构建事件驱动的服务器框架，然后利用AIO来实现异步非阻塞的I/O操作。这样可以充分发挥两者的优势，提供高性能和高并发性能的应用程序。

### 4. 为什么netty要拆成boss和worker，把accept和read/write分开的好处是什么？

Netty将网络处理拆分为boss和worker的原因是为了充分利用多核处理器的性能，提高网络应用程序的并发性和吞吐量。

主要好处如下：

1. 负载均衡：boss线程负责处理连接的接受（accept）操作，而worker线程负责实际的读取（read）和写入（write）操作。通过这种方式，boss线程可以专注于接受连接请求，而worker线程可以专注于实际的数据处理。这样可以实现连接请求的均衡分配，避免单个线程处理过多的连接。
2. 避免阻塞：boss线程在接受连接时通常不会阻塞，因为它仅仅是将新连接注册给worker线程处理。这样，即使有大量的连接请求到达，boss线程也能快速地接受并注册这些连接，不会阻塞整个系统。而worker线程负责实际的读写操作，可以通过非阻塞的方式处理大量的连接和数据。
3. 多核利用：通过将连接接受和数据处理分开，boss线程和worker线程可以并行地在多个核上执行。这充分利用了多核处理器的性能优势，可以提高系统的并发性能和吞吐量。
4. 线程池管理：Netty使用线程池来管理worker线程，可以灵活地配置和管理工作线程的数量。这样可以根据系统的负载和需求来动态调整worker线程的数量，以达到最佳的性能和资源利用。

总结来说，将Netty的网络处理拆分为boss和worker线程的方式可以实现负载均衡、避免阻塞、充分利用多核处理器，并提高网络应用程序的并发性和吞吐量。这种设计方式是为了优化网络应用程序的性能和可扩展性。

### 5. 知道惊群效应吗？

惊群效应是指在多进程或多线程环境下，当一个事件（如某个网络连接的可读或可写事件）发生时，多个进程或线程都竞争对该事件进行处理，导致不必要的资源浪费和性能下降的现象。

具体来说，在网络编程中，当一个监听套接字(socket)上有新连接到来时，所有等待该事件的进程或线程都会被唤醒，然后竞争去处理这个事件。这种竞争可能导致只有一个进程或线程真正处理了连接，而其他进程或线程则白白地被唤醒和竞争，浪费了系统资源。

为了避免惊群效应，可以采取以下策略：

1. 使用互斥锁：在等待事件的进程或线程之间使用互斥锁来保证只有一个进程或线程获得处理权。这样可以避免多个进程或线程同时竞争同一个事件。
2. 使用唤醒机制：在事件到来时，只唤醒一个进程或线程，而不是唤醒所有等待的进程或线程。这可以通过条件变量或其他同步机制来实现。
3. 使用事件分发器：引入一个事件分发器或调度器，它负责将事件分发给合适的进程或线程进行处理。这样可以避免所有进程或线程都竞争同一个事件。

在具体的系统设计和编程中，可以根据实际情况选择合适的策略来避免惊群效应。避免惊群效应可以提高系统的性能和资源利用率。

## 二、内存分配

### 1. Java是怎么做内存分配的，堆区怎么做内存管理的？

在Java中，内存分配是由Java虚拟机（JVM）负责的。JVM将内存分为不同的区域，分为堆（Heap）、栈（Stack）、方法区（Method Area）和本地方法栈（Native Method Stack）等部分，其中堆区是用于存储对象实例的主要区域。

Java的堆区内存管理是基于垃圾回收机制的。当Java程序创建对象时，对象存储在堆区中。堆区被划分为年轻代（Young Generation）和老年代（Old Generation）两个部分。

年轻代又被划分为Eden空间和两个Survivor空间（通常称为From空间和To空间）。当对象被创建时，它们会首先分配到Eden空间。当Eden空间满时，会触发Minor GC（年轻代垃圾回收），其中存活的对象会被复制到其中一个Survivor空间中，而不再存活的对象则被清理。

经过多次Minor GC后，仍然存活的对象将会被移到老年代。老年代一般包含着生命周期较长的对象。当老年代空间不足时，会触发Major GC（Full GC，即完全垃圾回收），对整个堆区进行垃圾回收，这个过程会比Minor GC更耗时。

垃圾回收过程中，不再被引用的对象会被标记为垃圾对象，垃圾回收器会清理这些对象并释放它们所占用的内存空间。Java的垃圾回收器使用了不同的算法，如标记-清除算法、复制算法、标记-整理算法等，来管理和清理堆区内存。

总结起来，Java的内存分配和堆区内存管理是由JVM负责的。JVM通过垃圾回收机制来管理堆区的内存，包括划分年轻代和老年代，使用不同的垃圾回收算法来清理不再使用的对象，以及在内存不足时进行垃圾回收操作。这种内存管理机制可以让开发人员专注于业务逻辑，而不需要手动管理内存的分配和释放。

### 2. 操作系统是怎么做内存管理的？

在传统的操作系统中，内存管理涉及以下几个主要方面：

1. 内存分配：操作系统负责将可用的物理内存划分为不同的区域，如内核区和用户区。用户区通常用于分配给进程和应用程序使用。内存分配的方式可以是连续分配（如分页和分段）或非连续分配（如虚拟内存管理）。
2. 地址映射：操作系统将逻辑地址（由进程或应用程序使用）映射到物理地址。地址映射的方式取决于所采用的内存管理方案。在分页和分段内存管理中，逻辑地址被映射到物理地址的页框或段。
3. 内存保护：操作系统通过内存保护机制确保各个进程或应用程序之间的内存空间相互隔离，防止彼此干扰或非法访问其他进程的内存。这可以通过使用页表或段表中的权限位来实现，限制进程对内存的访问权限。
4. 内存回收：当进程或应用程序终止或释放内存时，操作系统需要回收这些内存资源，并将其标记为可再分配的状态。这样，其他进程或应用程序可以再次分配和使用这些空闲内存。
5. 虚拟内存管理：虚拟内存是一种内存管理技术，将逻辑地址空间扩展到大于物理内存的范围。操作系统通过将内存中的页面（或块）交换到磁盘上的交换空间，并根据需要将其换回内存，实现了对更大地址空间的支持。

总的来说，操作系统的内存管理目标是有效地管理可用内存资源，为不同的进程和应用程序提供适当的内存空间，并确保内存访问的安全性和隔离性。这样可以提高系统的性能和稳定性，并为应用程序提供所需的内存支持。

### 3. JVM怎么向操作系统申请内存空间

JVM（Java虚拟机）在向操作系统申请内存空间时，通常使用操作系统提供的原生接口来完成这个过程。具体来说，JVM使用的是C/C++编程语言与操作系统进行交互，通过调用操作系统的内存管理功能来获取所需的内存空间。

JVM在启动时会预先分配一块较大的连续内存作为Java堆区（Heap），用于存放Java对象实例。这部分内存空间在操作系统的虚拟地址空间中是连续分布的。

当Java程序需要创建对象或分配内存时，JVM会根据对象的大小和类型来计算所需的内存空间。然后，JVM通过使用操作系统的原生接口，如C/C++的malloc()或操作系统特定的内存分配函数，向操作系统请求所需大小的内存空间。

操作系统收到JVM的内存申请请求后，会进行内存分配和管理。它会在操作系统的虚拟地址空间中寻找可用的连续内存块，然后将这些内存块标记为已分配状态，并返回一个指向该内存块起始位置的指针给JVM。

JVM接收到操作系统返回的内存起始地址后，将该地址记录下来，并将其返回给Java程序，使得Java程序可以使用这块内存来创建对象或存储数据。

需要注意的是，JVM在向操作系统申请内存空间时，一般会请求较大的内存块，然后在JVM内部进行管理和分配。这样可以减少频繁向操作系统申请内存的开销，并提高内存分配的效率。

总结起来，JVM通过调用操作系统提供的原生接口，如malloc()，向操作系统申请所需的内存空间。操作系统根据请求的大小进行内存分配，并返回一个指向内存块的指针给JVM，使得JVM可以将其用于Java对象的创建和数据存储。

### 4. JVM分代内存管理和操作系统内存管理的区别

1. 内存模型层次结构：JVM的内存管理是建立在操作系统的内存管理之上的。JVM的内存模型包括堆区、栈区、方法区等，而操作系统的内存管理是以物理内存为基础的，通常是以页为单位进行管理。
2. 内存分配单位：JVM的内存管理是以Java对象为单位进行分配和管理的，而操作系统的内存管理是以页或其他固定大小的内存块为单位进行分配和管理的。
3. 分代策略：JVM的分代内存管理是基于对象生命周期的概念进行的，将堆内存分为不同的代（如年轻代、老年代、永久代/元空间）。这样可以根据对象的生命周期来采用不同的垃圾回收算法和策略。而操作系统的内存管理通常没有将内存划分为不同的代，它更关注于物理内存的分配和回收。
4. 垃圾回收：JVM的内存管理涉及垃圾回收机制，通过标记和清除等算法来回收不再使用的对象。这使得开发人员无需手动释放内存。而操作系统的内存管理一般不涉及垃圾回收，而是依赖于进程的创建和终止来释放内存。
5. 内存保护和隔离：操作系统的内存管理涉及进程间的内存保护和隔离，确保每个进程只能访问其分配的内存空间，防止进程之间相互干扰。而JVM的内存管理更关注于Java程序内部的对象间的内存管理，保证对象的正确分配和释放。
6. 虚拟内存：操作系统提供虚拟内存技术，可以将磁盘上的数据映射到物理内存中，从而扩展可用内存空间。而JVM内存管理不涉及直接对虚拟内存的管理，虚拟内存是由操作系统负责管理和分配的。

总的来说，JVM的分代内存管理和操作系统的内存管理有一些共同点，例如内存分配和回收，但也存在一些区别。JVM的内存管理更加关注于Java对象的生命周期和垃圾回收，而操作系统的内存管理更注重于物理内存的分配和进程间的内存保护。两者在不同层次上进行内存管理，相互配合，共同为应用程序提供有效的内存资源。

### 5. 为什么操作系统不用分代策略呢

操作系统不使用分代策略的主要原因是出于设计和实现的考虑，以及针对操作系统的特定需求：

1. 设计和实现的简单性：操作系统的内存管理需要保持简单、高效和可靠。使用分代策略增加了内存管理的复杂性。分代策略需要跟踪对象的生命周期，并决定何时将对象晋升到下一个代，这会引入额外的开销和复杂性。而操作系统的内存管理更注重于对物理内存的高效分配和回收，以及进程的隔离和保护。
2. 空间和性能考虑：操作系统需要为多个进程提供内存资源，并确保每个进程有足够的内存可用。操作系统通常采用虚拟内存技术，将磁盘作为辅助存储，允许进程使用比物理内存更大的地址空间。在这种情况下，操作系统的内存管理更加注重于虚拟内存和页面置换算法，以优化整体系统的性能和资源利用率。
3. 进程隔离和保护：操作系统需要确保每个进程在内存中有独立的地址空间，以避免进程之间的相互干扰。进程间的地址空间隔离是通过操作系统的内存保护机制来实现的，如虚拟内存的地址映射和访问权限位。分代策略更适用于对象级别的内存管理，而不涉及进程间的地址空间隔离和保护。

需要指出的是，分代内存管理在Java虚拟机中被采用是因为Java语言的特点和需求。Java程序的内存使用模式通常具有大量的短寿命对象和少量的长寿命对象，而分代内存管理可以针对不同的对象生命周期采用不同的垃圾回收策略，提高垃圾回收的效率和性能。但是在操作系统层面，这种分代策略的优势并不明显，因此操作系统一般采用更简单和高效的内存管理策略。

## 三、MySQL事务

### 1. 事务的隔离级别有哪些？

1. 读未提交（Read Uncommitted）：最低级别的隔离级别，一个事务可以读取另一个未提交的事务所做的修改。这种级别下，存在脏读（Dirty Read）问题，即读取到了其他事务尚未提交的数据。
2. 读已提交（Read Committed）：在该级别下，一个事务只能读取已经提交的数据。其他事务对数据的修改在提交之前对当前事务不可见。但是，由于并发事务可能会对同一数据多次进行修改，所以在同一个事务内多次读取同一数据可能会得到不一致的结果，这种情况称为不可重复读（Non-repeatable Read）。
3. 可重复读（Repeatable Read）：在该级别下，一个事务在执行期间多次读取同一数据时，能够保证读取到的数据是一致的。其他事务对数据的修改在当前事务结束之前不可见。这种级别通过锁定读取的数据，防止其他事务对数据进行修改。但是仍然可能存在幻读（Phantom Read）问题，即在同一事务内多次查询时，结果集的行数可能会发生变化。
4. 可串行化（Serializable）：最高级别的隔离级别，它要求所有事务按照顺序依次执行，避免了脏读、不可重复读和幻读等问题。每个事务都会对要访问的数据进行锁定，直到事务结束才会释放。虽然可串行化级别保证了数据的完全一致性，但是它也带来了较高的并发性能开销，因为事务需要等待其他事务释放锁。

### 2. MVCC在哪个级别？

MVCC的实现方式可以存在于多个隔离级别中，但它常见且更常用的是在读已提交（Read Committed）和可重复读（Repeatable Read）两个隔离级别下。

在读已提交隔离级别下，MVCC通过在每个数据记录上维护事务版本号或时间戳的方式来实现。事务只能读取**已经提交的数据版本**，避免了脏读问题。当一个事务开始时，它会获得当前的数据库快照，并只能看到在事务开始之前已经提交的数据版本。其他事务对数据的修改只对后续的事务可见。

在可重复读隔离级别下，MVCC同样通过事务版本号或时间戳的方式实现。每个事务在开始时获取一个独立的快照，并只能看到**在事务开始之前已经提交的数据版本**。与读已提交隔离级别不同的是，可重复读级别下，一个事务在执行期间多次读取同一数据时，能够保证读取到的数据是一致的。这种一致性是通过锁定读取的数据版本，防止其他事务对数据进行修改来实现的。

需要注意的是，MVCC并非标准的隔离级别，而是一种并发控制机制，不同的数据库系统对于MVCC的具体实现可能会有差异。在实际应用中，读已提交和可重复读隔离级别常常与MVCC机制结合使用，以提供更好的并发性能和数据一致性。

### 3. MySQL的可重复读级别可以在一定程度上防止幻读，你知道它的原理吗？

MySQL引入了一种称为"Next-Key Locking"的机制来在一定程度上防止幻读的问题。它在MySQL的索引上使用了间隙锁（Gap Lock）和记录锁（Record Lock）：

- 间隙锁（Gap Lock）：间隙锁是在索引的范围之间的间隙上设置的锁，防止其他事务在这个范围内插入新的数据，从而防止了幻读。
- 记录锁（Record Lock）：记录锁是在索引中的具体记录上设置的锁，用于防止其他事务修改或删除该记录。

通过使用间隙锁和记录锁，"Next-Key Locking"机制可以在一定程度上防止幻读的发生。当一个事务在读取数据时，MySQL会为读取的数据行和索引之间的间隙设置间隙锁，这样其他事务无法在这个间隙中插入新的数据。如果一个事务需要修改数据，则会获取记录锁，阻塞其他事务对同一行的修改或删除操作。

需要注意的是，"Next-Key Locking"机制并不能完全消除幻读的问题。在某些特定的场景和操作下，幻读仍然可能发生。为了进一步减少幻读的发生，可以使用更高的隔离级别，如可串行化（Serializable），但这也会带来更大的并发性能开销。

### 4. undo_log和redo_log的功能

undo_log（回滚日志）和 redo_log（重做日志）是数据库管理系统中用于事务恢复和保证数据一致性的重要组成部分。它们在数据库事务处理中具有不同的功能和作用。

1. undo_log（回滚日志）：
   - 功能：undo_log用于记录事务对数据进行修改之前的旧值或修改前的数据状态。
   - 作用：当事务回滚或撤销时，通过undo_log可以将数据恢复到事务开始之前的状态，实现事务的回滚操作。
   - 实现方式：undo_log以日志的形式记录事务对数据的修改，包括插入、更新和删除操作。记录的内容可以是旧值、删除的数据或者其他数据的变更信息。
2. redo_log（重做日志）：
   - 功能：redo_log用于记录事务对数据的修改操作，包括插入、更新和删除操作。
   - 作用：当数据库发生故障或意外崩溃时，通过redo_log可以重新执行已经提交的事务，确保数据的持久性和一致性。
   - 实现方式：redo_log以日志的形式记录事务对数据的修改操作(具体解释在下面有)，而不是直接在数据文件中进行修改。当事务提交时，将修改操作记录到redo_log中，然后由数据库系统将这些操作应用到磁盘上的数据文件，从而保证数据的持久性。

通过使用undo_log和redo_log，数据库系统可以提供事务的回滚和持久性保证。

当事务需要回滚时，数据库系统可以通过undo_log中的信息将数据恢复到事务开始之前的状态，撤销对数据的修改。而在数据库系统发生故障或崩溃后，通过redo_log可以将已提交的事务重新执行，以恢复数据库的一致性。这两种日志的使用和管理是数据库事务处理和数据恢复的关键组件。

> **关于redo_log以日志的形式记录事务对数据的修改操作**
>
> 这句话要怎么理解呢？
>
> `MySQL` 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 `Buffer Pool` 中。后续的查询都是先从 `Buffer Pool` 中找，没有命中再去硬盘加载，减少硬盘 `IO` 开销，提升性能。更新表数据的时候，也是如此，发现 `Buffer Pool` 里存在要更新的数据，就直接在 `Buffer Pool` 里更新。然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（`redo log buffer`）里，接着刷盘到 `redo log` 文件里。
>
> 那么为什么不每次把修改后的数据页直接刷盘不就好了，还有 `redo log` 什么事？它们不都是刷盘么？差别在哪里？
>
> MySQL中的数据页大小是`16KB`，刷盘比较耗时，可能就修改了数据页里的几 `Byte` 数据，有必要把完整的数据页刷盘吗？而且数据页刷盘是随机写，因为一个数据页对应的位置可能在硬盘文件的随机位置，所以性能是很差。
>
> 如果是写 `redo log`，一行记录可能就占几十 `Byte`，再加上是顺序写，所以刷盘速度很快。
>
> redo_log记录的内容通常包括以下信息：
>
> 1. 数据页的修改：当事务对数据库中的某个数据页进行插入、更新或删除操作时，redo_log会记录这些物理修改。记录的内容可以是修改前的数据、修改后的数据或其他变更信息。
> 2. 日志序列号（LSN）：每个redo_log记录都包含一个唯一的日志序列号（Log Sequence Number，LSN），用于标识该记录的顺序和位置。通过LSN，可以确定redo_log记录的写入顺序和事务的提交顺序。
> 3. 事务ID和事务状态：redo_log记录还会包含与事务相关的信息，如事务ID和事务状态。这些信息用于标识和管理事务的提交状态，以及在数据库恢复过程中重新执行已提交事务。
> 4. 操作类型：redo_log记录会指示所记录的操作类型，如插入、更新或删除。这样在数据库恢复过程中，系统知道要执行哪种类型的操作。
> 5. 数据页位置：redo_log记录可能包含数据页的物理位置信息，例如数据文件的名称、页号等。这些信息用于在恢复阶段定位和访问需要修改的数据页。